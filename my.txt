https://realfavicongenerator.net/
https://realfavicongenerator.net/favicon-checker

npx realfavicon check 3000

..........

To remove unused imports or "using" statements in Visual Studio Code, you can use the shortcut Shift + Alt + O (or Shift + Option + O on macOS). 
....

import { useRouter } from 'next/router';
import Link from 'next/link';

function LocationPage() {
  const router = useRouter();
  
  // 1. Get URL params
  const { country, city, subCity } = router.query;
  
  // 2. Get current path
  const currentPath = router.asPath;
  
  // 3. Navigation function
  const navigateToHome = () => {
    router.push({
      pathname: '/home',
      query: { from: currentPath }, // Passing current path as state
    });
  };

  return (
    <div>
      <h1>{subCity}, {city}, {country}</h1>
      
      {/* Link navigation */}
      <Link href="/home">
        <a>Go Home</a>
      </Link>
      
      {/* Programmatic navigation */}
      <button onClick={navigateToHome}>
        Navigate Programmatically
      </button>
    </div>
  );
}


..............


import dynamic from 'next/dynamic';
import SEO from '@/components/SEO';
import { getHomeSEOAPI } from '@/api/apiService';

// ✅ Dynamic import (lazy load Home component)
const Home = dynamic(() => import('@/components/NewHome'), { ssr: false });

// If SEO data doesn't change frequently, use getStaticProps with revalidation instead of getServerSideProps.
// Use getStaticProps + Revalidation (ISR - Incremental Static Regeneration)
// Since the SEO data rarely changes, use getStaticProps with revalidate.

// Fast page loading ✅

// Updated automatically after a specific interval ✅
export async function getStaticProps() {
  try {
    const seoData = await getHomeSEOAPI();

    return {
      props: { seoData },
      revalidate: 3600, // Revalidate every 1 hour
    };
  } catch (error) {
    console.error('SEO Fetch Error:', error);
    return { props: { seoData: {} }, revalidate: 3600 };
  }
}
// ✅ Page loads instantly
// ✅ No API call on every request
// ✅ Updates automatically every 1 hour

// :::::::::::: getServerSideProps (If SEO is different for every request)

// export async function getServerSideProps() {
//   try {
//     const seoData = await getHomeSEOAPI();
//     return { props: { seoData } };
//   } catch (error) {
//     console.error("SEO Fetch Error:", error);
//     return { props: { seoData: {} } };
//   }
// }

// ✅ Always up-to-date
// ❌ Slower than static pages

//  :::::::::::: getStaticPaths + getStaticProps (For Common Locations)

// export async function getStaticPaths() {
//   const cities = await getAllCities();
//   const paths = cities.map(({ country, city }) => ({
//     params: { country, city },
//   }));

//   return { paths, fallback: "blocking" };
// }

// export async function getStaticProps({ params }) {
//   const { country, city } = params;

//   try {
//     const seoData = await getDynamicSEOAPI(country, city);
//     return { props: { seoData }, revalidate: 86400 }; // Revalidate every 24 hours
//   } catch (error) {
//     console.error("SEO Fetch Error:", error);
//     return { props: { seoData: {} }, revalidate: 86400 };
//   }
// }

// ✅ Faster than getServerSideProps
// ✅ Revalidates every 24 hours
// ✅ Works well if the number of cities is fixed

export default function HomePage({ seoData }) {
  return (
    <>
      <SEO seoData={seoData} /> {/* ✅ SEO loads immediately */}
      <Home /> {/* 🛑 Lazy-loaded for better performance */}
    </>
  );
}



=============== Post ===================
export async function getStaticPaths() {
  const posts = await getAllPostSlugs(); // e.g., [{ slug: 'post-1' }, { slug: 'post-2' }, ...]
  const paths = posts.map((post) => ({
    params: { slug: post.slug },
  }));
  return {
    paths, // Pre-render these paths at build time
    fallback: 'blocking', // Generate other pages on-demand
  };
}

export async function getStaticProps({ params }) {
  try {
    const post = await getPostBySlug(params.slug);
    if (!post) {
      return { notFound: true };
    }
    const seoData = { ... }; // Dynamic SEO data
    return {
      props: { post, seoData },
      revalidate: 60, // Regenerate every 60 seconds for updates
    };
  } catch (error) {
    console.error('Post Fetch Error:', error);
    return {
      props: { post: null, seoData: {} },
      revalidate: 60,
    };
  }
}

=============== Post Detail ===================
// pages/posts/index.js
import { getAllPosts } from '@/api/apiService';

export async function getStaticProps() {
  const posts = await getAllPosts();
  return {
    props: { posts },
    revalidate: 60,
  };
}

export default function PostsPage({ posts }) {
  return (
    <div>
      <h1>All Posts</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.slug}>
            <a href={`/posts/${post.slug}`}>{post.title}</a>
          </li>
        ))}
      </ul>
    </div>
  );
}


=================== Site Map =========
-- Check Demo Also
// pages/sitemap.xml.js
import { getAllPostSlugs } from '@/api/apiService';

export async function getServerSideProps({ res }) {
  const posts = await getAllPostSlugs();
  const sitemap = `<?xml version="1.0" encoding="UTF-8"?>
    <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
      ${posts
        .map((post) => `
          <url>
            <loc>https://localxlist.org/posts/${post.slug}</loc>
            <lastmod>${new Date().toISOString()}</lastmod>
            <changefreq>daily</changefreq>
            <priority>0.7</priority>
          </url>
        `)
        .join('')}
    </urlset>`;

  res.setHeader('Content-Type', 'text/xml');
  res.write(sitemap);
  res.end();

  return { props: {} };
}

export default function Sitemap() {
  return null;
}


========== RSS =====
// pages/rss.xml.js
import { getAllPosts } from '@/api/apiService';

export async function getServerSideProps({ res }) {
  const posts = await getAllPosts();
  const rss = `<?xml version="1.0" encoding="UTF-8"?>
    <rss version="2.0">
      <channel>
        <title>Localxlist Blog</title>
        <link>https://localxlist.org</link>
        <description>Latest posts from Localxlist</description>
        ${posts
          .map((post) => `
            <item>
              <title>${post.title}</title>
              <link>https://localxlist.org/posts/${post.slug}</link>
              <description>${post.excerpt}</description>
              <pubDate>${new Date(post.createdAt).toUTCString()}</pubDate>
            </item>
          `)
          .join('')}
      </channel>
    </rss>`;

  res.setHeader('Content-Type', 'application/rss+xml');
  res.write(rss);
  res.end();

  return { props: {} };
}

export default function RSS() {
  return null;
}


=================== Breadcrumb Link ===================
Option 1: Use linkAs with proper child structure (Recommended)

<Breadcrumb.Item
  linkAs={Link}
  href={ROUTES.home || "/"}
>
  <a>Home</a>
</Breadcrumb.Item>

,,,
Option 2: Use as prop with Next.js Link

<Breadcrumb.Item>
  <Link href={ROUTES.home || "/"} passHref legacyBehavior>
    <a>Home</a>
  </Link>
</Breadcrumb.Item>

,,,
Option 3: Create a custom Breadcrumb component

const CustomBreadcrumbItem = ({ href, children }) => (
  <Breadcrumb.Item>
    <Link href={href} passHref legacyBehavior>
      <a>{children}</a>
    </Link>
  </Breadcrumb.Item>
);

// Usage
<CustomBreadcrumbItem href={ROUTES.home || "/"}>
  Home
</CustomBreadcrumbItem>

=================== DIR TREE =========
// Display Dir Tree structure through command prompt
tree src/pages /F

=================== ROBOT.txt ===============
src/pages/api/robots.js
export default function handler(req, res) {
    const robots = `
  User-agent: *
  Allow: /
  
  # Disallow sensitive or irrelevant pages
  Disallow: /api/*
  Disallow: /forgot-password
  Disallow: /forgot-verification
  Disallow: /reset-password
  Disallow: /signup-verification
  Disallow: /login
  Disallow: /signup
  
  # Sitemap
  Sitemap: https://www.localxlist.com/sitemap.xml
  `;

    res.setHeader('Content-Type', 'text/plain');
    res.write(robots);
    res.end();
}

// For Direct check run robots.txt
next.config.js
async rewrites() {
  return [ { source: '/robots.txt', destination: '/api/robots' }];
},